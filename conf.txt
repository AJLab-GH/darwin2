========================================================
File content of vue/src/components/04-rest-api/RestAPIManagement.vue
========================================================
<template>
  <div class="card my-4">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5>REST API</h5>
      <i class="bi bi-question-circle-fill bs-icon" style="font-size: 1.5rem" @click="showHelp = !showHelp"></i>
      <!-- Bootstrap icon for help -->
    </div>

    <div class="card-body">
      <p>
        This tool provides two primary sets of API tasks for quick onboarding and decommissioning of the application.<br>After completing these tasks, you can
        verify the application's accessibility at <a href="http://speedtest.corp.fabriclab.ca" target="_blank">http://speedtest.corp.fabriclab.ca</a>.
      </p>

      <div class="container">
        <div class="row">
          <div class="col-md-6">
            <div class="card">
              <div class="card-header">
                <button class="btn btn-primary btn-sm me-2" @click="createPolicy" :disabled="createLoading">
                  <span v-if="createLoading" class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                  <span>{{ createLoading ? "Creating..." : "Create" }}</span>
                </button>
                <button class="btn btn-secondary btn-sm" @click="resetResult">Reset</button>
              </div>

              <ul class="list-group list-group-flush">
                <li v-for="(task, index) in tasks" :key="index" class="list-group-item d-flex justify-content-between">
                  <span>{{ task.description }}</span>
                  <span :class="['badge', 'rounded-pill', task.colorClass]">{{ task.statusText }}</span>
                </li>
              </ul>
            </div>
          </div>
          <div class="col-md-6">
            <div class="card">
              <div class="card-header">
                <button class="btn btn-primary btn-sm me-2" @click="deletePolicy" :disabled="deleteLoading">
                  <span v-if="deleteLoading" class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                  <span>{{ deleteLoading ? "Deleting..." : "Delete" }}</span>
                </button>
                <button class="btn btn-secondary btn-sm" @click="resetDeleteResult">Reset</button>
              </div>

              <ul class="list-group list-group-flush">
                <li v-for="(deleteTask, index) in deleteTasks" :key="index" class="list-group-item d-flex justify-content-between">
                  <span>{{ deleteTask.description }}</span>
                  <span :class="['badge', 'rounded-pill', deleteTask.colorClass]">{{ deleteTask.statusText }}</span>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Card -->
  <div v-if="showHelp" class="card bg-light mb-3">
    <div class="card-header">
      <h5>About FortiWeb Rest API</h5>
    </div>
    <div class="card-body">
      <p>
        FortiWeb provides an API that uses Representational State Transfer (RESTful API) design principles to access and modify the settings of FortiWeb
        applications.
      </p>
      <p>
        You can use the RESTful API to control FortiWeb and seamlessly integrate FortiWeb to other systems. With a secure and programmable management style by
        HTTPS+ authentication, FortiWeb RESTful API provides enough convenience for those who hope to integrate FortiWeb with other configurations. Furthermore,
        FortiWeb RESTful API can help realize comprehensive management on all FortiWeb features.
      </p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      jobResult: [], // Initialize as an empty array
      createLoading: false,
      deleteLoading: false,
      showHelp: false,

      tasks: [
        { id: "createNewVirtualIP", description: "Create new Virtual IP", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        { id: "createNewServerPool", description: "Create new Server Pool", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        { id: "createNewMemberPool", description: "Create new Member Pool", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        { id: "createNewVirtualServer", description: "Create new Virtual Server", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        {
          id: "assignVIPToVirtualServer",
          description: "Assign Virtual IP to Virtual Server",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        {
          id: "cloneSignatureProtection",
          description: "Clone Signature Protection",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        { id: "cloneInlineProtection", description: "Clone Inline Protection", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        {
          id: "createNewXForwardedForRule",
          description: "Create new X-Forwarded-For Rule",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        {
          id: "configureProtectionProfile",
          description: "Configure Protection Profile",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        { id: "createNewPolicy", description: "Create new Policy", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
      ],

      deleteTasks: [
        { id: "deletePolicy", description: "Delete Policy", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        {
          id: "deleteInlineProtection",
          description: "Delete Inline Protection Profile",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        {
          id: "deleteXForwardedForRule",
          description: "Delete X-Forwarded-For Rule",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        {
          id: "deleteSignatureProtection",
          description: "Delete Signature Protection",
          status: "incomplete",
          colorClass: "bg-secondary",
          statusText: "Incomplete",
        },
        { id: "deleteVirtualServer", description: "Delete Virtual Server", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        { id: "deleteServerPool", description: "Delete Server Pool", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
        { id: "deleteVirtualIP", description: "Delete Virtual IP", status: "incomplete", colorClass: "bg-secondary", statusText: "Incomplete" },
      ],
    };
  },

  methods: {
    updateTaskStatus(taskId, status) {
      let task = this.tasks.find((t) => t.id === taskId);
      if (task) {
        task.status = status;
        if (status === "success") {
          task.colorClass = "bg-success";
          task.statusText = "Done";
        } else if (status === "failure") {
          task.colorClass = "bg-danger";
          task.statusText = "Failed";
        }
      }
    },

    updateDeleteTaskStatus(taskId, status) {
      let task = this.deleteTasks.find((t) => t.id === taskId);
      if (task) {
        task.status = status;
        if (status === "success") {
          task.colorClass = "bg-success";
          task.statusText = "Done";
        } else if (status === "failure") {
          task.colorClass = "bg-danger";
          task.statusText = "Failed";
        }
      }
    },

    createPolicy() {
      this.resetResult();
      this.resetDeleteResult();
      this.createLoading = true;
      console.log("Creating policy...");

      fetch("http://localhost:8080/create-policy", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
      })
        .then((response) => response.json())
        .then((data) => {
          console.log("Results", data);
          this.createLoading = false;
          this.jobResult = data;
          data.forEach((status) => {
            this.updateTaskStatus(status.taskId, status.status);
          });
        })
        .catch((error) => {
          console.error("Error creating policy:", error);
          this.createLoading = false;
        });
    },

    deletePolicy() {
      this.resetResult();
      this.resetDeleteResult();
      this.deleteLoading = true;
      console.log("Deleting policy...");

      fetch("http://localhost:8080/delete-policy", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
      })
        .then((response) => response.json())
        .then((data) => {
          console.log("Policy deleted successfully:", data);
          this.deleteLoading = false;
          this.jobResult = data;
          data.forEach((status) => {
            this.updateDeleteTaskStatus(status.taskId, status.status);
          });
        })
        .catch((error) => {
          console.error("Error deleting policy:", error);
          this.deleteLoading = false;
        });
    },

    resetResult() {
      this.tasks = this.tasks.map((task) => ({
        ...task,
        status: "incomplete",
        colorClass: "bg-secondary",
        statusText: "Incomplete",
      }));
    },

    resetDeleteResult() {
      this.deleteTasks = this.deleteTasks.map((task) => ({
        ...task,
        status: "incomplete",
        colorClass: "bg-secondary",
        statusText: "Incomplete",
      }));
    },
  },
};
</script>

<style></style>

========================================================
File content of vue/src/router/index.js
========================================================
import { createRouter, createWebHistory } from 'vue-router';

// Import components from each folder
import HomePage from '../components/HomePage.vue';

import WebScan from '../components/01-web-protection/WebScan.vue';
import TrafficGeneration from '../components/01-web-protection/TrafficGeneration.vue';
import WebAttacks from '../components/01-web-protection/WebAttacks.vue';
import MachineLearning from '../components/01-web-protection/MachineLearning.vue';
import CookieSecurity from '../components/01-web-protection/CookieSecurity.vue';
import CredentialStuffingDefense from '../components/01-web-protection/CredentialStuffingDefense.vue';

import BiometricsBasedDetection from '../components/02-bot-mitigation/BiometricsBasedDetection.vue';
import BotDeception from '../components/02-bot-mitigation/BotDeception.vue';
import KnownBots from '../components/02-bot-mitigation/KnownBots.vue';
import MLBasedBotDetection from '../components/02-bot-mitigation/MLBasedBotDetection.vue';
import ThresholdBasedDetection from '../components/02-bot-mitigation/ThresholdBasedDetection.vue';

import ApiRequests from '../components/03-api-protection/ApiRequests.vue';
import ApiTrafficGeneration from '../components/03-api-protection/ApiTrafficGeneration.vue';

import RestAPIManagement from '../components/04-rest-api/RestAPIManagement.vue';

import ConfigForm from '../components/05-tool/ConfigForm.vue';
import HealthCheck from '../components/05-tool/HealthCheck.vue';
import AppDocker from '../components/05-tool/AppDocker.vue';
import FortiWebBootstrap from '../components/05-tool/FortiWebBootstrap.vue';

const routes = [
  { path: '/', component: HomePage },

  { path: '/web-scan', component: WebScan },
  { path: '/traffic-generation', component: TrafficGeneration },
  { path: '/web-attacks', component: WebAttacks },
  { path: '/machine-learning', component: MachineLearning },
  { path: '/cookie-security', component: CookieSecurity },
  { path: '/credential-stuffing-defense', component: CredentialStuffingDefense },

  { path: '/biometrics-based-detection', component: BiometricsBasedDetection },
  { path: '/bot-deception', component: BotDeception },
  { path: '/known-bots', component: KnownBots },
  { path: '/ml-based-bot-detection', component: MLBasedBotDetection },
  { path: '/threshold-based-detection', component: ThresholdBasedDetection },

  { path: '/api-requests', component: ApiRequests },
  { path: '/api-traffic-generation', component: ApiTrafficGeneration },

  { path: '/rest-api-management', component: RestAPIManagement },

  { path: '/configuration', component: ConfigForm },
  { path: '/health-check', component: HealthCheck },
  { path: '/app-docker', component: AppDocker },
  { path: '/bootstrap', component: FortiWebBootstrap },

];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;

========================================================
File content of go/utils/restApiCommonUtils.go
========================================================
package utils

import (
	"bytes"
	"crypto/tls"
	"darwin2/config"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// /////////////////////////////////////////////////////////////////////////////
func GenerateAPIToken() string {
	tokenData := fmt.Sprintf(`{"username":"%s","password":"%s","vdom":"%s"}`, config.CurrentConfig.USERNAMEAPI, config.CurrentConfig.PASSWORDAPI, config.CurrentConfig.VDOMAPI)
	return base64.StdEncoding.EncodeToString([]byte(tokenData))
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// /////////////////////////////////////////////////////////////////////////////
func SendRequest(method, url, token string, data interface{}) ([]byte, error) {
	// fmt.Println("Sending HTTP Request...")
	var req *http.Request
	var err error

	reqData := config.Request{
		Data: data,
	}

	jsonData, err := json.Marshal(reqData)
	if err != nil {
		fmt.Printf("Error marshaling JSON data: %v\n", err)
		return nil, err
	}

	// Convert jsonData to string for comparison
	jsonDataStr := string(jsonData)

	if jsonDataStr != "" && jsonDataStr != `{"data":null}` {
		// Create a new request with JSON data
		req, err = http.NewRequest(method, url, bytes.NewBuffer(jsonData))
		if err != nil {
			fmt.Printf("Error creating HTTP request: %v\n", err)
			return nil, err
		}
	} else {
		// Create a new request without data
		req, err = http.NewRequest(method, url, nil)
		if err != nil {
			fmt.Printf("Error creating HTTP request: %v\n", err)
			return nil, err
		}
	}

	req.Header.Set("Authorization", token)
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Content-type", "application/json")

	// Create a custom HTTP client with SSL/TLS certificate verification disabled
	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}

	// fmt.Println("Sending HTTP Request...")
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Error sending HTTP request: %v\n", err)
		return nil, err
	}

	defer resp.Body.Close()

	// fmt.Println("Waiting for response...")
	time.Sleep(time.Duration(1000) * time.Millisecond)

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading response body: %v\n", err)
		return nil, err
	}

	// fmt.Println("Received HTTP Response")
	return body, nil
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// /////////////////////////////////////////////////////////////////////////////
func CheckOperationStatus(result []byte) bool {
	var res map[string]interface{}
	json.Unmarshal(result, &res)

	// Check if the result map is empty
	if len(res) == 0 {
		return false
	}

	// Check if the "data" field is null
	if data, ok := res["data"]; ok && data == nil {
		return false
	}

	if _, ok := res["results"].(map[string]interface{})["errcode"]; ok {
		// The result contains an error code, so the operation failed
		return false
	}
	// The operation succeeded
	return true
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func ValidateInput(input interface{}) error {
	// Utilisez la réflexion pour inspecter l'input
	val := reflect.ValueOf(input)

	// Exemple de validation : vérifier si l'input est un struct et non nil
	if val.Kind() != reflect.Struct || val.IsNil() {
		return errors.New("invalid input: expect a struct")
	}

	// Parcourir les champs du struct pour des validations spécifiques
	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)

		// Exemple de validation : vérifier si les champs string ne sont pas vides
		if field.Kind() == reflect.String && field.String() == "" {
			return fmt.Errorf("invalid input: field %s is empty", val.Type().Field(i).Name)
		}

		// Ajoutez ici d'autres règles de validation selon vos besoins
	}

	// Si tout est valide
	return nil
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// /////////////////////////////////////////////////////////////////////////////
func FormatError(err error) map[string]string {
	// Création d'une map pour structurer le message d'erreur
	errorMap := make(map[string]string)

	if err != nil {
		// Formatage du message d'erreur
		errorMap["error"] = err.Error()
	} else {
		// Gestion d'un cas où err est nil (aucune erreur)
		errorMap["error"] = "unknown error"
	}

	// Renvoi de la map formatée
	return errorMap
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

========================================================
File content of go/handlers/restApiCreateHandlers.go
========================================================
package handlers

import (
	"darwin2/config"
	"darwin2/utils"
	"fmt"
	"net/http"
	"net/url"

	"github.com/labstack/echo/v4"
)

type ApiResult struct {
	TaskID      string
	Description string
	Status      string
	Message     string
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 1: Create new Virtual IP
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCreateNewVirtualIP(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()

	vipData := config.VirtualIPData{
		Name:      config.VipName,
		Vip:       config.VipIp,
		Interface: config.Interface,
	}

	result := ApiResult{
		TaskID:      "createNewVirtualIP",
		Description: "Create new Virtual IP",
	}

	resultBody, err := createNewVirtualIP(fwbmgtip, token, vipData)
	if err != nil {
		result.Status = "failure"
		result.Message = fmt.Sprintf("Error creating virtual IP: %v", err)
	} else if !utils.CheckOperationStatus(resultBody) {
		result.Status = "failure"
		result.Message = "Failed to create virtual IP"
	} else {
		result.Status = "success"
		result.Message = "Successfully created virtual IP"
	}

	return c.JSON(http.StatusOK, result)
}

func createNewVirtualIP(host, token string, data config.VirtualIPData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/system/vip", host)

	return utils.SendRequest("POST", url, token, data)
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 2: Create new Server Pool
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCreateNewServerPool(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()

	poolData := config.ServerPoolData{
		Name:          config.PoolName,
		ServerBalance: config.ServerBalance,
		Health:        config.HealthCheck,
    }

	result := ApiResult{
		TaskID:      "createNewServerPool",
		Description: "Create new Server Pool",
	}

	resultBody, err := createNewVirtualIP(fwbmgtip, token, poolData)
	if err != nil {
		result.Status = "failure"
		result.Message = fmt.Sprintf("Error creating Server Pool: %v", err)
	} else if !utils.CheckOperationStatus(resultBody) {
		result.Status = "failure"
		result.Message = "Failed to create Server Pool"
	} else {
		result.Status = "success"
		result.Message = "Successfully created Server Pool"
	}

    return c.JSON(http.StatusOK, result)
}

func createNewServerPool(host, token string, data config.ServerPoolData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/server-policy/server-pool", host)

	return utils.SendRequest("POST", url, token, data)

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 3: Create new Member Pool
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCreateNewMemberPool(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
   	poolName := config.PoolName

    poolMembers := make([]config.MemberPoolData, len(config.PoolMemberIPs))
	for i, ip := range config.PoolMemberIPs {
		poolMembers[i] = config.MemberPoolData{IP: ip, SSL: config.PoolMemberSSL, Port: config.PoolMemberPort}
	}

    result := ApiResult{
        TaskID:      "createNewMemberPool",
        Description: "Create new Member Pool",
    }

    for _, member := range poolMembers {
        resultBody, err := createNewMemberPool(fwbmgtip, token, poolName, member)
        if err != nil {
            result.Status = "failure"
            result.Message = fmt.Sprintf("Error creating Member Pool: %v", err)
        } else if !checkOperationStatus(resultBody) {
            result.Status = "failure"
            result.Message = "Failed to create Member Pool"
        } else {
            result.Status = "success"
            result.Message = "Successfully created Member Pool"
        }
    }

    return c.JSON(http.StatusOK, result)
}

func createNewMemberPool(host, token, poolName string, data config.MemberPoolData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/server-policy/server-pool/pserver-list?mkey=%s", host, url.QueryEscape(poolName))

	return utils.SendRequest("POST", url, token, data)
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 4: Create new Virtual Server
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCreateNewVirtualServer(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
	vsData := config.VirtualServerData{
		Name: config.VirtualServerName,
	}

    result := ApiResult{
		TaskID:      "createNewVirtualServer",
		Description: "Create new Virtual Server",
	}

	resultBody, err := createNewVirtualServer(fwbmgtip, token, vsData)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error creating Virtual Server: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to create Virtual Server"
	} else {
			result.Status =      "success"
			result.Message =     "Successfully created Virtual Server"
	}

	return c.JSON(http.StatusOK, result)
}

func createNewVirtualServer(host, token string, data config.VirtualServerData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/server-policy/vserver", host)

	return utils.SendRequest("POST", url, token, data)
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 5: Assign Virtual IP to Virtual Server
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleAssignVIPToVirtualServer(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
    virtualServerName := config.VirtualServerName

	assignVIPData := config.AssignVIPData{
		Interface: config.Interface,
		Status:    config.VipStatus,
		VipName:   config.VipName,
	}

    result := ApiResult{
        TaskID:      "assignVIPToVirtualServer",
        Description: "Assign Virtual IP to Virtual Server",
    }

	resultBody, err = assignVIPToVirtualServer(fwbmgtip, token, virtualServerName, assignVIPData)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error assigning VIP to Virtual Server: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to assign VIP to Virtual Server"
	} else {
			result.Status =      "success",
			result.Message =     "Successfully assigned VIP to Virtual Server"
	}

	return c.JSON(http.StatusOK, result)
}

func assignVIPToVirtualServer(host, token, virtualServerName string, data config.AssignVIPData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/server-policy/vserver/vip-list?mkey=%s", host, url.QueryEscape(virtualServerName))

	return utils.SendRequest("POST", url, token, data)
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 6: Clone Signature Protection
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCloneSignatureProtection(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
	originalKey := config.OriginalSignatureProtectionName
	cloneKey := config.CloneSignatureProtectionName
    
    result := ApiResult{
        TaskID:      "cloneSignatureProtection",
        Description: "Clone Signature Protection",
    }

	resultBody, err = cloneSignatureProtection(fwbmgtip, token, originalKey, cloneKey)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error cloning Signature Protection: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to clone Signature Protection"
	} else {
			result.Status =      "success"
			result.Message =     "Successfully cloned Signature Protection"
	}

	return c.JSON(http.StatusOK, result)
}

func cloneSignatureProtection(host, token, originalKey, cloneKey string) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/waf/signature?mkey=%s&clone_mkey=%s", host, url.QueryEscape(originalKey), url.QueryEscape(cloneKey))

	return utils.SendRequest("POST", url, token, nil)
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 7: Clone Inline Protection
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCloneInlineProtection(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
	originalKey := config.OriginalInlineProtectionProfileName
	cloneKey := config.CloneInlineProtectionProfileName

    result := ApiResult{
        TaskID:      "cloneInlineProtection",
        Description: "Clone Inline Protection",
    }

	resultBody, err = cloneInlineProtection(fwbmgtip, token, originalKey, cloneKey)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error cloning Inline Protection: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to clone Inline Protection"
	} else {
			result.Status =      "success"
			result.Message =     "Successfully cloned Inline Protection"
		}
	}

	return c.JSON(http.StatusOK, result)
}

func cloneInlineProtection(host, token, originalKey, cloneKey string) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/waf/web-protection-profile.inline-protection?mkey=%s&clone_mkey=%s", host, url.QueryEscape(originalKey), url.QueryEscape(cloneKey))

	return utils.SendRequest("POST", url, token, nil)
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 8: Create new X-Forwarded-For Rule
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCreateNewXForwardedForRule(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
	xffData := config.XForwardedForData{
		Name:                 config.XForwardedForName,
		XForwardedForSupport: config.XForwardedForSupport,
	}

    result := ApiResult{
        TaskID:      "createNewXForwardedForRule",
        Description: "Create new X-Forwarded-For Rule",
    }

	resultBody, err = createNewXForwardedForRule(fwbmgtip, token, xffData)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error creating new X-Forwarded-For Rule: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to create new X-Forwarded-For Rule"
	} else {
			result.Status =      "success"
			result.Message =     "Successfully created new X-Forwarded-For Rule"
	}

	return c.JSON(http.StatusOK, result)
}

func createNewXForwardedForRule(host, token string, data config.XForwardedForData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/waf/x-forwarded-for", host)

	return utils.SendRequest("POST", url, token, data)
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 9: Configure Protection Profile
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleConfigureProtectionProfile(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()
	cloneKey := config.CloneInlineProtectionProfileName

    protectionProfileData := config.ProtectionProfileData{
		SignatureRule:     config.CloneSignatureProtectionName,
		XForwardedForRule: config.XForwardedForName,
	}

    result := ApiResult{
        TaskID:      "configureProtectionProfile",
        Description: "Configure Protection Profile",
    }

	resultBody, err = configureProtectionProfile(fwbmgtip, token, cloneKey, protectionProfileData)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error configuring Protection Profile: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to configure Protection Profile"
	} else {
			result.Status =      "success"
			result.Message =     "Successfully configured Protection Profile"
	}

	return c.JSON(http.StatusOK, result)
}

func configureProtectionProfile(host, token, mkey string, data config.ProtectionProfileData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/waf/web-protection-profile.inline-protection?mkey=%s", host, url.QueryEscape(mkey))

	return utils.SendRequest("PUT", url, token, data)
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Step 10: Create new Policy
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func HandleCreateNewPolicy(c echo.Context) error {
	fwbmgtip := config.CurrentConfig.FWBMGTIP
	token := utils.GenerateAPIToken()

	policyData := config.PolicyData{
		Name:                    config.PolicyName,
		DeploymentMode:          config.PolicyDeploymentMode,
		Protocol:                config.PolicyProtocol,
		Ssl:                     config.PolicySSL,
		ImplicitSsl:             config.PolicyImplicitSSL,
		Vserver:                 config.PolicyVirtualServer,
		Service:                 config.PolicyService,
		InlineProtectionProfile: config.PolicyInlineProtectionProfile,
		ServerPool:              config.PolicyServerPool,
		TrafficLog:              config.PolicyTrafficLog,
		HttpsService:            config.PolicyHTTPSService,
	}

    result := ApiResult{
        TaskID:      "configureProtectionProfile",
        Description: "Configure Protection Profile",
    }

	resultBody, err = createNewPolicy(fwbmgtip, token, policyData)
	if err != nil {
			result.Status =      "failure"
			result.Message =     fmt.Sprintf("Error creating new Policy: %v", err)
	} else if !checkOperationStatus(resultBody) {
			result.Status =      "failure"
			result.Message =     "Failed to create new Policy"
	} else {
			result.Status =      "success"
			result.Message =     "Successfully created new Policy"
	}

	return c.JSON(http.StatusOK, result)
}

func createNewPolicy(host, token string, data config.PolicyData) ([]byte, error) {
	url := fmt.Sprintf("https://%s/api/v2.0/cmdb/server-policy/policy", host)

	return utils.SendRequest("POST", url, token, data)
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

========================================================
File content of go/config/restapi_config.go
========================================================
package config

var (
	VipName                             = "SPEEDTEST_VIP"
	VipIp                               = "192.168.4.40/24"
	Interface                           = "port1"
	PoolName                            = "SPEEDTEST_POOL"
	ServerBalance                       = "enable"
	HealthCheck                         = "HLTHCK_HTTP"
	PoolMemberIPs                       = []string{"10.0.0.10", "10.0.0.20", "10.0.0.30"}
	PoolMemberSSL                       = "disable"
	PoolMemberPort                      = 5000
	VirtualServerName                   = "SPEEDTEST_VS"
	VipStatus                           = "enable"
	XForwardedForName                   = "SPEEDTEST_X_FORWARDED_FOR"
	XForwardedForSupport                = "enable"
	OriginalSignatureProtectionName     = "Standard Protection"
	CloneSignatureProtectionName        = "SPEEDTEST_SIGNATURE_CLONE"
	OriginalInlineProtectionProfileName = "Inline Standard Protection"
	CloneInlineProtectionProfileName    = "SPEEDTEST_PROTECTION_CLONE"
	PolicyName                          = "SPEEDTEST_POLICY"
	PolicyDeploymentMode                = "server-pool"
	PolicyProtocol                      = "HTTP"
	PolicySSL                           = "enable"
	PolicyImplicitSSL                   = "enable"
	PolicyVirtualServer                 = VirtualServerName
	PolicyService                       = "HTTP"
	PolicyInlineProtectionProfile       = CloneInlineProtectionProfileName
	PolicyServerPool                    = PoolName
	PolicyTrafficLog                    = "enable"
	PolicyHTTPSService                  = "HTTPS"
	//PolicyCertificate                   = "speedtest.corp.fabriclab.ca"
)

// Data Types Struct

type VirtualIPData struct {
	Name      string `json:"name,omitempty"`
	Vip       string `json:"vip,omitempty"`
	Interface string `json:"interface,omitempty"`
}

type ServerPoolData struct {
	Name          string `json:"name,omitempty"`
	ServerBalance string `json:"server-balance,omitempty"`
	Health        string `json:"health,omitempty"`
}

type MemberPoolData struct {
	IP   string `json:"ip,omitempty"`
	SSL  string `json:"ssl,omitempty"`
	Port int    `json:"port,omitempty"`
}

type VirtualServerData struct {
	Name string `json:"name,omitempty"`
}

type AssignVIPData struct {
	Interface string `json:"interface,omitempty"`
	Status    string `json:"status,omitempty"`
	VipName   string `json:"vip,omitempty"`
}

type Request struct {
	Data interface{} `json:"data"`
}

type XForwardedForData struct {
	Name                 string `json:"name,omitempty"`
	XForwardedForSupport string `json:"x-forwarded-for-support,omitempty"`
}

type ProtectionProfileData struct {
	SignatureRule     string `json:"signature-rule,omitempty"`
	XForwardedForRule string `json:"x-forwarded-for-rule,omitempty"`
}

type PolicyData struct {
	Name                    string `json:"name,omitempty"`
	DeploymentMode          string `json:"deployment-mode,omitempty"`
	Protocol                string `json:"protocol,omitempty"`
	Ssl                     string `json:"ssl,omitempty"`
	ImplicitSsl             string `json:"implicit_ssl,omitempty"`
	Vserver                 string `json:"vserver,omitempty"`
	Service                 string `json:"service,omitempty"`
	InlineProtectionProfile string `json:"web-protection-profile,omitempty"`
	ServerPool              string `json:"server-pool,omitempty"`
	TrafficLog              string `json:"tlog,omitempty"`
	HttpsService            string `json:"https-service,omitempty"`
	Certificate             string `json:"certificate,omitempty"`
}

========================================================
File content of go/routes/routes.go
========================================================
package routes

import (
	"darwin2/config"
	"darwin2/handlers"

	"github.com/labstack/echo/v4"
)

func Configure(e *echo.Echo) {

	// Web Protection
	e.POST("/web-scan", handlers.HandleWebScan)
	e.POST("/web-attacks", handlers.HandleWebAttacks)
	e.POST("/traffic-generation", handlers.HandleTrafficGenerator)
	e.POST("/machine-learning", handlers.HandleMachineLearning)
	e.POST("/user-auth", handlers.HandleUserAuth)
	e.POST("/cookie-security", handlers.HandleCookieSecurityAttack)

	// Bot Mitigation
	// API Protection
	e.POST("/api-get", handlers.HandleApiGet)
	e.POST("/api-post", handlers.HandleApiPost)
	e.POST("/api-put", handlers.HandleApiPut)
	e.POST("/api-delete", handlers.HandleApiDelete)
	e.POST("/api-traffic-generation", handlers.HandleApiMachineLearning)

	// REST API CREATE
	e.POST("/create-virtual-ip", handlers.HandleCreateNewVirtualIP)
	e.POST("/create-server-pool", handlers.HandleCreateNewServerPool)
	e.POST("/create-member-pool", handlers.HandleCreateNewMemberPool)
	e.POST("/create-virtual-server", handlers.HandleCreateNewVirtualServer)
	e.POST("/assign-vip-to-virtual-server", handlers.HandleAssignVIPToVirtualServer)
	e.POST("/clone-signature-protection", handlers.HandleCloneSignatureProtection)
	e.POST("/clone-inline-protection", handlers.HandleCloneInlineProtection)
	e.POST("/create-x-forwarded-for-rule", handlers.HandleCreateNewXForwardedForRule)
	e.POST("/configure-protection-profile", handlers.HandleConfigureProtectionProfile)
	e.POST("/create-policy", handlers.HandleCreateNewPolicy)

	// REST API DELETE
	e.DELETE("/delete-virtual-ip", handlers.HandleDeleteVirtualIP)
	e.DELETE("/delete-server-pool", handlers.HandleDeleteServerPool)
	e.DELETE("/delete-virtual-server", handlers.HandleDeleteVirtualServer)
	e.DELETE("/delete-signature-protection", handlers.HandleDeleteSignatureProtection)
	e.DELETE("/delete-x-forwarded-for-rule", handlers.HandleDeleteXForwardedForRule)
	e.DELETE("/delete-policy", handlers.HandleDeletePolicy)

	// System
	e.GET("/config", config.GetConfig)
	e.POST("/config", config.UpdateConfig)
	e.GET("/reset", config.ResetConfig)

}

========================================================
